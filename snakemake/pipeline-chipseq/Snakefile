#!/usr/bin/env python

from glob import glob;
import os;


def fastq_files(wildcards):
    return glob(os.path.join(config["fastq_dir"], "*.f*q"))


def fastq_names(wildcards):
    return [os.path.splitext(os.path.basename(fastq_file))[0] for fastq_file in fastq_files(wildcards)]


def fastq_common_names_paired(wildcards):
    basenames = {os.path.splitext(fastq_file)[0] for fastq_file in fastq_files(wildcards)}
    paired_candidates = [basename[:-2] for basename in basenames if basename[-2:] == "_1"]
    return [os.path.basename(common_name) for common_name in paired_candidates if common_name + "_2" in basenames]


def fastq_names_single(wildcards):
    common_names = fastq_common_names_paired(wildcards)
    return [fastq_name for fastq_name in fastq_names(wildcards) if fastq_name[-2:] not in ["_1", "_2"] or fastq_name[:-2] not in common_names]


def fastq_aligned_names(wildcards):
    return fastq_common_names_paired(wildcards) + fastq_names_single(wildcards)


def expect_files(wildcards, directory, extension, suffix=""):
    return [os.path.join(directory, "{}{}.{}".format(filename, suffix, extension)) for filename in fastq_names(wildcards)]


def expect_aligned_files(wildcards, directory, extension):
    return [os.path.join(directory, "{}.{}".format(filename, extension)) for filename in fastq_aligned_names(wildcards)]

fastqc_dir = os.path.join(config["work_dir"], "fastqc")
bams_dir = os.path.join(config["work_dir"], "bams")
bws_dir = os.path.join(config["work_dir"], "bws")


def fastqc_files(wildcards):
    return expect_files(wildcards, fastqc_dir, "html", "_fastqc")


workdir: config["work_dir"]


rule all:
    input:
        multiqc=os.path.join(config["work_dir"], "multiqc_report.html"),
        multiqc_bams=os.path.join(bams_dir, "multiqc_report.html"),
        bws=lambda wildcards: expect_aligned_files(wildcards, bws_dir, "bw"),
        bam_qc=lambda wildcards: expect_aligned_files(wildcards, "bam/qc", "phantom.tsv"),
        bam_qc_pbc=lambda wildcards: expect_aligned_files(wildcards, "bam/qc", "pbc_nrf.tsv")
    shell: 'echo {input}'


rule download_chrom_sizes:
    output: "{}.chrom.sizes".format(config["genome"])
    shell: 'wget -nc -O {output} http://hgdownload.cse.ucsc.edu/goldenPath/{config[genome]}/bigZips/{config[genome]}.chrom.sizes'


rule download_fa:
    output: directory(os.path.join(config["work_dir"], "fa"))
    shell: 'rsync -avzP --exclude="*.txt" rsync://hgdownload.cse.ucsc.edu/goldenPath/{config[genome]}/chromosomes/ {output} && '
           'gunzip -f {output}/*.fa.gz'


rule clip_to_bw:
    input:
        clip=os.path.join(bws_dir, "{sample}_sorted.clip"),
        cs=rules.download_chrom_sizes.output
    output: os.path.join(bws_dir, "{sample}.bw")
    shell: 'bedGraphToBigWig {input.clip} {input.cs} {output}'


rule clip_sort:
    input: os.path.join(bws_dir, "{sample}.clip")
    output: temp(os.path.join(bws_dir, "{sample}_sorted.clip"))
    shadow: "minimal"
    params:
        tmp_dir="tmp"
    shell: 'mkdir -p {params.tmp_dir} && '
           'LC_COLLATE=C sort -k1,1 -k2,2n -T {params.tmp_dir} {input} > {output}'


rule bdg_to_clip:
    input:
        bdg=os.path.join(bws_dir, "{sample}.bdg"),
        cs=rules.download_chrom_sizes.output
    output: temp(os.path.join(bws_dir, "{sample}.clip"))
    shell: 'bedtools slop -i {input.bdg} -g {input.cs} -b 0 | bedClip stdin {input.cs} {output}'


rule bam_to_bdg:
    input:
        bam=os.path.join(bams_dir, "{sample}.bam"),
        cs=rules.download_chrom_sizes.output
    output: temp(os.path.join(bws_dir, "{sample}.bdg"))
    shell: 'bedtools genomecov -ibam {input.bam} -bg -g {input.cs} > {output}'


rule multiqc_bams:
    input: lambda wildcards: expect_aligned_files(wildcards, bams_dir, "bam")
    output: os.path.join(bams_dir, "multiqc_report.html")
#    params:
#        output_dir=lambda wildcards, output: os.path.dirname(str(output))
#    shell: 'multiqc "{params.output_dir}"'
# uncomment when the logic is fixed
    shell: 'touch {output}'


rule align_single_sam:
    input:
        fastq=os.path.join(config["fastq_dir"], "{sample}.fastq"),
        indexes=directory(os.path.join(config["work_dir"], "indexes"))
    output: temp(os.path.join(bams_dir, "{sample}.sam"))
    threads: 4
    shell: 'bowtie -p {threads} -St -m 1 -v 3 --trim5 5 --best --strata {config[genome]} {input.fastq} {output}'


rule align_paired_sam:
    input:
        first=os.path.join(config["fastq_dir"], "{sample}_1.fastq"),
        second=os.path.join(config["fastq_dir"], "{sample}_2.fastq"),
        indexes=directory(os.path.join(config["work_dir"], "indexes"))
    output: temp(os.path.join(bams_dir, "{sample}.sam"))
    threads: 4
    shell: 'bowtie -p {threads} -St -m 1 -v 3 --trim5 5 --best --strata {config[genome]} '
           '-1 {input.first} -2 {input.second} {output}'


rule sam_to_unsorted_bam:
    input: os.path.join(bams_dir, "{sample}.sam")
    output: temp(os.path.join(bams_dir, "{sample}_not_sorted.bam"))
    shell: 'samtools view -bS {input} -o {output}'


rule sort_bam:
    input: os.path.join(bams_dir, "{sample}_not_sorted.bam")
    output: os.path.join(bams_dir, "{sample, (?:(?!_not_sorted$).)*}.bam")
    shell: 'samtools sort {input} -o {output}'


rule multiqc:
    input: fastqc_files
    output: os.path.join(config["work_dir"], "multiqc_report.html")
    shell: 'multiqc -o "{config[work_dir]}" "{fastqc_dir}"'


rule fastqc:
    input: os.path.join(config["fastq_dir"], "{sample}.fastq")
    output: os.path.join(fastqc_dir, "{sample}_fastqc.html")
    params:
        output_dir=lambda wildcards, output: os.path.dirname(str(output))
    shell: 'fastqc --outdir "{params.output_dir}" "{input}"'


rule index_bowtie:
    input: directory(os.path.join(config["work_dir"], "fa"))
    output: directory(os.path.join(config["work_dir"], "indexes"))
    params:
        files_list=lambda wildcards, input: ','.join(glob("{}/*.fa".format(input))),
        target=lambda wildcards, output: os.path.join(str(output), config["genome"])
    shell: 'mkdir -p {output} && '
           'bowtie-build {params.files_list} {params.target}'


rule download_phantompeakqualtools:
    output: directory("bin/phantompeakqualtools")
    params:
        targz="phantompeakqualtools.tar.gz"
    shell: 'cd bin && '
           'curl --location '
           'https://storage.googleapis.com/google-code-archive-downloads/v2/'
           'code.google.com/phantompeakqualtools/ccQualityControl.v.1.1.tar.gz '
           '--output {params.targz} && '
           'tar xvf {params.targz}'


rule bam_qc_phantom:
    input:
        ppqt_dir=rules.download_phantompeakqualtools.output,
        bam="bams/{sample}.bam"
    output: "bams/qc/{sample}.phantom.tsv"
    params:
        run_spp=lambda wildcards, input: os.path.join(str(input.ppqt_dir), "run_spp.R")
    shell: 'Rscript {params.run_spp} -c={input.bam} -savp -out={output}'


rule bam_to_pileup:
    input: "bams/{sample}.bam"
    output: temp("bams/pileup/{sample}.bed")
    shell: 'bedtools bamtobed -i {input} > {output}'


rule bam_qc_pbc_nrf:
    input: rules.bam_to_pileup.output
    output: "bams/qc/{sample}.pbc_nrf.tsv"
    shadow: "minimal"
    params:
        tmp_dir="tmp"
    shell: """
mkdir -p {params.tmp_dir} &&
(T=$'\\t'
>&2 echo "TotalReadPairs${{T}}DistinctReadPairs${{T}}OneReadPair${{T}}TwoReadPairs${{T}}\
NRF=Distinct/Total${{T}}PBC1=OnePair/Distinct${{T}}PBC2=OnePair/TwoPair"

cat {input} | \
    sort -k1,1 -k3,3n -k2,2n -k6,6 -T {params.tmp_dir} | \
    awk -v OFS='\\t' '{{print $1,$2,$3,$6}}' | uniq -c | \
    awk 'BEGIN{{mt=0;m0=0;m1=0;m2=0}}
    ($1==1){{m1=m1+1}} ($1==2){{m2=m2+1}} {{m0=m0+1}} {{mt=mt+$1}}
    END{{
        if (mt!=0){{m0_t=m0/mt}} else {{m0_t=-1.0}};
        if (m0!=0){{m1_0=m1/m0}} else {{m1_0=-1.0}};
        if (m2!=0){{m1_2=m1/m2}} else {{m1_2=-1.0}};
        printf "%d\\t%d\\t%d\\t%d\\t%f\\t%f\\t%f\\n",mt,m0,m1,m2,m0_t,m1_0,m1_2;
    }}') > {output}
"""
